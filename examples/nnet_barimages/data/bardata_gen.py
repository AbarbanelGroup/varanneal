"""
Generate training or test data for Sasha's bar image example.

This script generates M labeled examples of noisy images of solid bars, oriented
either horizontally, vertically, or diagonally at a 45-degree angle.  You have 
the choice of generating only centered bars, or bars centered on any/all pixels
within the image field.  This is done by setting the "imagetype" flag.

All data will be generated by adding noise to the image such that the values of 
the pixels are no longer either zero or one.
"""

import numpy as np

################################################################################
# You can set the options for the data in this section. You don't need to
# change anything in beyond here, unless you want to manually alter the data
# generation procedures for some reason
################################################################################

# Set the type of images you'd like to generate
#imagetype = "centered"  # bars all centered in middle of image
imagetype = "allpositions"  # bars centered on all pixels

# Set dimension of images (must be odd!), i.e. images will be square and dim X dim pixels
dim = 3

# Number of training example *sets*, meaning Nsets output sets containing one of 
# every possible bar location.
Nsets = 2

# Image noise seed
np.random.seed(85964309)

# Ouptut data file names
# Make sure both of them end with the same file extension, either .npy or .dat
data_fname = "training_data.npy"
label_fname = "training_label.npy"

################################################################################
# Don't need to touch any code beyond this point, unless you want to manually
# alter the data-generating procedure for some reason.
################################################################################

# Check for valid image dimension
if dim < 3:
    print("ERROR: Desired image dimension dim = %d is too small. Must be 3 or greater. Exiting!")
    sys.exit(1)
if dim%2 == 0:
    print("ERROR: Image dimension must be odd. Exiting!")
    sys.exit(1)

size = (dim, dim)  # size tuple for the image arrays

# These arrays define the canonical noiseless images. All angled bars here are
# either h_i (at zero or 180 degrees) d1_i (pi/4 or 5pi/4), v_i, (+/- pi/2), or
# d2_i (3pi/4 or -pi/4) where the angle is measured from the left horizontal.

# Vertical and horizontal images
for i in xrange(dim):
    exec "v%d = np.zeros((dim, dim), dtype='int')"%(i+1,)
    exec "v%d[:, i] = 1"%(i+1,)
    exec "h%d = np.zeros((dim, dim), dtype='int')"%(i+1,)
    exec "h%d[i, :] = 1"%(i+1,)

# Diagonal images
Ndiag = 2*dim - 3  # number of possible diagonals
for i in xrange(Ndiag):
    if i <= Ndiag/2:
        v = np.ones(i + 2)
    else:
        v = np.ones(Ndiag - i + 1)
    exec "d1%d = np.diag(v, -(Ndiag/2) + i)"%(i+1,)
    exec "d2%d = np.fliplr(d1%d)"%(i+1, i+1)

# Generates centered data
if imagetype == "centered":
    data = np.zeros((4*Nsets, dim*dim), dtype=np.float64)
    labels = np.zeros((4*Nsets, 4), dtype=np.int8)
    hvidx = dim/2 + 1
    diagidx = Ndiag/2 + 1
    for m in xrange(Nsets):
        exec "data[4*m, :] = (h%d + 0.35*(0.5 - np.random.random_sample(size))).flatten()"%(hvidx,)
        exec "data[4*m+1, :] = (v%d + 0.35*(0.5 - np.random.random_sample(size))).flatten()"%(hvidx,)
        exec "data[4*m+2, :] = (d1%d + 0.35*(0.5 - np.random.random_sample(size))).flatten()"%(diagidx,)
        exec "data[4*m+3, :] = (d2%d + 0.35*(0.5 - np.random.random_sample(size))).flatten()"%(diagidx,)
        labels[4*m, :] = np.array([1,0,0,0])  # horizontal label
        labels[4*m+1, :] = np.array([0,0,1,0])  # vertical label
        labels[4*m+2, :] = np.array([0,1,0,0])  # diag label
        labels[4*m+3, :] = np.array([0,0,0,1])  # flipped diag label

    if data_fname.endswith(".npy"):
        np.save(data_fname, data)
        np.save(label_fname, labels)
    else:
        np.savetxt(data_fname, data, fmt="%.8e")
        np.savetxt(label_fname, labels, fmt="%d")

    #for i in xrange(M):
    #    exec "datah%d = h%d + 0.35 * (0.5 - np.random.random_sample(size))"%(hvidx, hvidx)
    #    exec "datav%d = v%d + 0.35 * (0.5 - np.random.random_sample(size))"%(hvidx, hvidx)
    #    exec "datad1%d = d1%d + 0.35 * (0.5 - np.random.random_sample(size))"%(diagidx, diagidx)
    #    exec "datad2%d = d2%d + 0.35 * (0.5 - np.random.random_sample(size))"%(diagidx, diagidx)
    #    with open("datacentered.txt", "ab") as mydata:
    #        exec "np.savetxt(mydata, [datah%d.flatten()])"%(hvidx)
    #        exec "np.savetxt(mydata, [datav%d.flatten()])"%(hvidx)
    #        exec "np.savetxt(mydata, [datad1%d.flatten()])"%(diagidx)
    #        exec "np.savetxt(mydata, [datad2%d.flatten()])"%(diagidx)
    #    with open("labelcentered.txt", "ab") as mylabel:
    #        np.savetxt(mylabel,[np.array([1,0,0,0])])
    #        np.savetxt(mylabel,[np.array([0,0,1,0])])
    #        np.savetxt(mylabel,[np.array([0,1,0,0])])
    #        np.savetxt(mylabel,[np.array([0,0,0,1])])

if imagetype == "allpositions":   
    # Generates images centered on all pixels
    M = Nsets*(2*dim + 2*Ndiag)
    data = np.zeros((M, dim*dim), dtype=np.float64)
    labels = np.zeros((M, 4), dtype=np.int8)
    idx = 0
    for m in xrange(Nsets):
        for j in xrange(1, dim+1):
            exec "data[idx, :] = (h%d + 0.35 * (0.5 - np.random.random_sample(size))).flatten()"%(j,)
            labels[idx, :] = np.array([1,0,0,0])
            idx += 1
        for j in xrange(1, dim+1):
            exec "data[idx, :] = (v%d + 0.35 * (0.5 - np.random.random_sample(size))).flatten()"%(j,)
            labels[idx, :] = np.array([0,0,1,0])
            idx += 1
        for j in xrange(1, Ndiag+1):
            exec "data[idx, :] = (d1%d + 0.35 * (0.5 - np.random.random_sample(size))).flatten()"%(j,)
            labels[idx, :] = np.array([0,1,0,0])
            idx += 1
        for j in xrange(1, Ndiag+1):
            exec "data[idx, :] = (d2%d + 0.35 * (0.5 - np.random.random_sample(size))).flatten()"%(j,)
            labels[idx, :] = np.array([0,0,0,1])
            idx += 1

    if data_fname.endswith(".npy"):
        np.save(data_fname, data)
        np.save(label_fname, labels)
    else:
        np.savetxt(data_fname, data, fmt="%.8e")
        np.savetxt(label_fname, labels, fmt="%d")
    
    #for i in xrange(Nsets):
    #    for j in xrange(1, dim+1):
    #        exec "datah%d = h%d + 0.35 * (0.5 - np.random.random_sample(size))"%(j, j)
    #    for j in xrange(1, dim+1):
    #        exec "datav%d = v%d + 0.35 * (0.5 - np.random.random_sample(size))"%(j, j)
    #    for j in xrange(1, Ndiag+1):
    #        exec "datad1%d = d1%d + 0.35 * (0.5 - np.random.random_sample(size))"%(j, j)
    #    for j in xrange(1, Ndiag+1):
    #        exec "datad2%d = d2%d + 0.35 * (0.5 - np.random.random_sample(size))"%(j, j)
    #    with open("data.txt", "ab") as mydata:
    #        for j in xrange(1, dim+1):
    #            exec "np.savetxt(mydata, [datah%d.flatten()])"%(j,)
    #        for j in xrange(1, dim+1):
    #            exec "np.savetxt(mydata, [datav%d.flatten()])"%(j,)
    #        for j in xrange(1, Ndiag+1):
    #            exec "np.savetxt(mydata, [datad1%d.flatten()])"%(j,)
    #        for j in xrange(1, Ndiag+1):
    #            exec "np.savetxt(mydata, [datad2%d.flatten()])"%(j,)
    #    with open("label.txt", "ab") as mylabel:
    #        for j in xrange(dim):
    #            np.savetxt(mylabel, [np.array([1,0,0,0])])
    #        for j in xrange(dim):
    #            np.savetxt(mylabel,[np.array([0,0,1,0])])
    #        for j in xrange(Ndiag):
    #            np.savetxt(mylabel,[np.array([0,1,0,0])])
    #        for j in xrange(Ndiag):
    #            np.savetxt(mylabel,[np.array([0,0,0,1])])
